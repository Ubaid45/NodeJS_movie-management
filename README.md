# Mongoose: Modelling Relationships between Connected Data
## Referencing a document
```javascript
const courseSchema = new mongoose.Schema({
    author: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Author"
    }
})
```
```javascript
const courseSchema = new mongoose.Schema({
    author: {
        type: new mongoose.Schema({
            name: String,
            bio: String
        })
    }
})
```
- Embedded documents don’t have a save method. They can only be saved in the context of their parent.

## Updating an embedded document
```javascript
const course = await Course.findById(courseId);
course.author.name = "New Name";
course.save();
```
- We don’t have transactions in MongoDB. To implement transactions, we use a pattern called **“Two Phase Commit”**. If you don’t want to manually implement this pattern, use the **[Fawn NPM package](https://www.npmjs.com/package/fawn)**:
### Implementing transactions using Fawn
```javascript
try {
    // All args in here treated all together as unit
    await new Fawn.Task()
        // First arg is collection we work with, and second is obj we wanna save
        .save('rentals', newRental)
        .update('movies', { _id: movie._id }, {
            $inc: { numberInStock: -1 }
        })
        .run();
} catch (ex) {
    // 500 means Internal server error
    res.status(500).send('Something failed.');
}
```
## Object IDs
- ObjectIDs are generated by MongoDB driver and are used to uniquely identify a document. They consist of 12 bytes: 
  - 4 bytes: timestamp
  - 3 bytes: machine identifier
  - 2 bytes: process identifier
  - 3 bytes: counter 
- ObjectIDs are almost unique. In theory, there is a chance for two ObjectIDs to be equal but the odds are very low (1/16,000,000) for most real-world applications.

### Validating ObjectIDs
```javascript
mongoose.Types.ObjectID.isValid(id); 
```
- To validate ObjectIDs using joi, use **[joi-objectid NPM package](https://www.npmjs.com/package/joi-objectid)**.
